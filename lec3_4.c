// consp by: @ulwww1_3 (tg)
/*
ЛЕКЦИЯ 3
/*
a && b/a > c //если у нас первый аргумент а!=0 => второй аргумент будет корректен(не нужно проверять на 0)

округление:
~ середина окргуляется до ближайшего целого четного(2,5 до 2; 3,5 до 4);
~ < середины к наименьшему ближайшему целому (3,3 до 3);
~ > середины к наибольшему наименьшему целому (4,9 до 5);

Указатели:(
Указатели похожи на ярлычки(файлик который указывает на другой файлик)^_^
        Указатели хранят адрес другой переменной

Как работает:

//int a,b;
//int *p; (* - модификатор унарного типа)
//int* p; - вторая форма для записи, скаков не одобряет
// p =&a; (унарный амперсанд) работает только для объектов
//*p = 2; (обращение сквозь указатель (a=2))

//Пример 1:
void z(int *x)
{
    (*x)++; //здесь скобки обяз, потому что приоритет у ++ выше
    *x += 1; //здесь скобки не нужны
}
int y = 0;
z(&y);
res: y = 3

//Пример 2:
int f(int a, int b, int *c)
{
    *c  = a % b;
    return a/b;
}
int a,b,c,d;
a = f(b, 3, &d)

можем с помощью указателей обращаться к чужой локальной переменной
        ~ если мы не инициализируем указатель (то все конец сломалось, будет мусор)
        int *p = NUll; (гарантированно не будет доступности для обращение к памяти, указатель не указывает ни на какой объект)

FILE *f = fopen(..);
if (!f==NULL)
{
...
}

ЛЕКЦИЯ 4

Указатель на указателе:
//int **z;
Пример1:
int a;
int *p = &a;
int **z;
z = &p;

Пример2
int main( int argc, char **argv)
{
    int x;
    if (argc!=z)
        if (sscanf(argv[i], "%i", &x)!=1) //чтение из строки
            argv[0]
    argc[1]
}

struct A; (пользовательский тип данных, создает не объект, а тип данных) типо как поля в java
{
int x;
float y;
} z;
struct A b;
{
//обращение к структуре
b.x
        b.y
}
// список указтель на на тот же тип
// двухсвязный список на след и пред
//sizeof(b) - вернет размер объекта b в char

!!!полезная конструкция
typedef unsigned int uint;

typedef struct A //чтобы постоянное не писать struct
{
    int x;
    float y;
} A;

A b;
A *p;
p=&b;
(*p).x ~~ p->x

        Модификаторы:
const int x = 2; //по этому объекту нельзя больше сделать присваивание, требует инициализации
const int *p = &x; //p указатель на const x, (*p = 0) так нельзя
Пример:
int f(int x, const int *p) //хотим передать функцию не копируя её
int f(int x, const A *p) //если принимает указатель, который мы не используем для изменения значения и тд
        int *const p = &x; //так нельзя (p=&y), *p = 4 можно
        const int a = z;
//int *p = &a; так нельзя

        Область видимости и время жизни переменных:
//время жизни переменных
void f (void)
{
    itn *p;
    if () {
        int a;
        p = &a;
    }
    *p = 3; // ахах, ты проиграл a больше нет:(
}
//область видимости можем создавать несколько одинаковых переменных, только в разных фигурных скобочках
void f (void)
{
    int a = 3;
    itn *p = &a;
    if ()
    {
        int a = 2;
        *p-=10;
    }
    int z = a;
    //res = -7
}
Глобальные переменные:
int g; //видны во всех функциях, даже можем юзать в другом файле(extern int g), инициализируется 0 // не имба (баллы снимут)
// const int g = 34; // имба
// будешь использовать вместо указателей глобальные переменные баллы снимут

Модификатор static:
static видно как локальную, живет как глобальная
static const int g = 34;
static void... //модифицирует видимость глобальноего объекта ограничивая его


        вывод ошибки: fprintf(stderr,  )
        */