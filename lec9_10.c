// дата: 9.03. МАССИВЫ

#include <stdlib.h>

int main() {
    int q[10]; // от q[0] до q[9]
    // если обратиться out of range: скорее всего мусор, но есть шанс что массив находится на границе выделенной операционной памяти
    // и тогда обращение за пределы этой памяти роняет программу

    //если записывать: либо упадет (маловероятно), либо запишет в какую то другую переменную (куда то)
    // можно попасть в адресс возврата

    // в си это без проверок но быстро. есть средства которые позволяют првоерять но они замедляют программу, только для отладки

    // инициализация массива  (происходит там же где локальные переменные)
    // должен инициализироваться целиком, если колво аргументов != размеру массива, в неуказанные значения пишутся нули
    int q2[10] = {1,2,3,4,5,6,7,8,9,0} ;
    int q3[10] = {}; // так можно делать после 23 стандарта, до - внутрь записывать хотя бы 1 ноль

    int q4[10] = {[2] = 2, [9] = 3}; //переменные вместо цифр быть не могут // только при инициализации // при обращении не туда ошибка компиляции

    struct {
        int a;
        double b;
        int c;

        int d[3];
    } my_x = {.a = 1, 1.5, .c = 4, {2, 3, 4}}; //b = 0, в си можно менять порядок аргументов, в плюсах так нельзя

    // статические переменные: глобальные с точки зрения памяти где они определяются, локальыне с точки зрения где их видно

    // при увеличении стэка вершина стэка опускается
    // максимальная размерность стэка / массива - пара мегабайт

    int *g = malloc(sizeof(int) * 10); //выделение памяти под десять интов // сайзов чара в стандарте 1 по определению
    // malloc - стандартная функция си, системная функция выделения памяти / требует библиотеку
    // возвращаеь НЕТИПИЗИРОВАННЫЙ указатель, но не знает на что вы выделяет память // указатель на void (неизвестно что)
    // в плюсах - операция приведения типа перед маллок (int*) обязатально

    free(g); // освобожление памяти ОБЯЗАТЕЛЬНО если сам ее выделяешь

    realloc(g, sizeof(int) * 10); // перевыделение памяти, как увеличение, так и обрезание, новое место неинициализированно
    //возможно захочет переместить данные, если после выделенной области место занято, старая область освободится
    // в таком случае лучше переопределять указатель, поскольку старый не валиден. если реалок не удался, старый продолжает действовать, а
    // функ возвращает нульпоинтер
    // по хорошему завести новый указатель, проверить на неравенство нулл и только тогда обновить старый указатель, иначе обработать ошибку непереносности памяти
    // фактическое (физическую оперативку выделяют) выделение памяти просиходит только при обращении (для винды и линкса, про дефолты скаков сказал он хз)

    int array[10]; //дальше будет q
    int *p;
    p = &q[0];
    p = q;

    //массивы можно считать указателями
    // q[0] = 2 / *q[2] одно и то же

    /*

     p = &q[0];
     p = p + 1; //передвинем указатель вперед на 1... элемент (размер инта) (зависит от типа указателя) / p +=1 p++ все работает как обычно
     *p = 3; // аналогично q[1] = 3
     p - q = 1 как целое число (не совсем инт) // расстояние между указателями одного объекта // разница со знаком // типа ptrdiff_t (аналог dize_t, но со знаком)

     указатели можно сравнивать

     *(q+5) = 4 // означает q[5] = 4 массив можно считать указателем на его начало
     * аналогично
     * p[4] === *(p + 4) //квадратные скобочки === к указателю прибавить сколько вы сказали и обратиться в это место через указатель
     ИЗ ЭТОГО ВСЕГО СЛЕДУЕТ: 4[p] - рабочее, но чисто для прикола

    *(p-3) === p[-3] _______ -3[p] /че то ломается. потому что в си нет отрицательных констант, и из-за того
     * что приоритет квадратных скобочек выше унарного минуса, он отрывается и унарный минус умножается на значение 3[p]
    (-3)[p]

     что есть &p = указатель на укалатель (получим адрес по которому лежит адрес по которому лежит инт) // двойной взять нельзя, потому что & возвращает число
     тип p = указатель на инт, такой тип
     что есть &q = все равно адрес начала массива
     */

    // массивы нельзя передавать в функции
     void f(int q[5]); //- хуйня === void f(int *q); //сам массив не передается, если что то поменяется - поменяется и исходный массив, обычные переменные просто копируются

     //массив перестает быть массивом когда мы его куда то передаем

     //чтобы передавать копию: оборачиваем его в структуру, потому что структура копируется


     // погугли: что есть структура в Си


     // многомерный массив
     int j[4][3]; // высота ширина -> z,y,x в памяти идет по строкам | столбцам слева направо сверху вниз
     // в некоторых случаях приходится использоватт наоборот, например - матрицы, фортрановское соглашение | pro-major / connon (common?)-major

     int *w[4]; // массив из 4х указателей на инт (на какие то другие одномерные массивы интов) // на рисуночке 4 строки
     w[1][2]; // попадем в 2й элемент (нум с нуля) второй строки // суперпохоже на обращение к элементу логика та же работае по разному
     // w = массив содержащий указатели массивов, указывает на несвязанные между собой и не связанные с ним, сразу не существуют
     // гадость, но работает при например поменять строки местами
     // j = двумерный массив НЕПРЕРЫВНЫЙ ПОСЛЕДОВАТЕЛЬНЫЙ БЛОК ПАМЯТИ обычное обращение работает быстрее

     // узнать размер массива зная массив: sizeof(a) / sizeof(*a), где *a - элемент массива

     int y = 38; //что то рандомное
     int width = 23;
     int heigh = 10;
     int x = 9;
     // что случается с динамическим выделением памяти под двумерные данные
    int *png = malloc(sizeof(int)*width*heigh);

    //тогда обращение происходит таким образом
    png[y * width + x]; //аналогично q[y][x]


    int (*png1)[width] = malloc(sizeof(int)*width*heigh); // для выделение памяти для заранее неизвестных это ура ура ванлав тогда можно  обращаться по q[y][w]
}




























